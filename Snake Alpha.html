<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Game Alpha</title>
<link href="http://fonts.googleapis.com/css?family=Oswald:400,700" rel="stylesheet" type="text/css">
<style>
* {
	padding: 0;
	border: 0;
	margin: 0;
	box-sizing: border-box;
	font-family: 'Oswald', sans-serif;
}
html {
	height: 100%;
	width: 100%;
}
body {
	height: 100%;
	width: 100%;
	background-color: black;
	overflow: hidden;
}
header {
	height: 10%;
	background-color: white;
}
#title_screen {
	display:flex;
	align-content:center;
	justify-content:center;
	flex-wrap:wrap;
	flex-direction:row;
	background-color: rgba(255,255,255,1);
	opacity:0;
	border-radius: 20px;
	position: absolute;
	top: 50%;
	left: 50%;
	margin: -250px 0 0 -250px;
	z-index: 100;
	width: 500px;
	height: 500px;
}
#title, #subtitle, #playButton {opacity:0;}
#title{font-size:100px;}
#subtitle{font-size:30px;margin-bottom:10px;}
#playButton{background-color:red;font-size:20px;padding:10px;width:100%;height:50px;transition:all .5s;}
#playButton:hover{background-color:blue;color:white;}
.playType{
	width:33.33%;
	height:50px;
	background-color: black;
	color:white;
	transition:all .5s;
}
.playType:hover{background-color:blue;color:white;}
.playType.active{
	background-color:blue;color:white;
}

.score{}
#playerOneScore, #playerTwoScore{
	position: absolute;
	top:50px;
	font-size: 40px;
}

#playerOneScore{
	left:45%;
	color:blue;
	display: none;
}

#playerTwoScore{
	right:45%;
	color:red;
	display: none;
}
#grid {
	width: 100%;
	height: 100%;
}
#grid div {
	float: left;
	width: 2vw;
	height: 3vh;
	background-color: black;
	margin: .5vh .5vw .5vh .7vw;
	transition: .1s all linear;
	border-radius: 100px;
}

</style>
</head>

<body onLoad="gridConstructor()">
<!--<header>Snake By Sage</header>-->
<div id="title_screen"> 
<h1 id="title">Snake</h1>
<h2 id="subtitle">Coded By: Sage Pacheco</h2>
<button id="playButton" onClick="startGame()" type="button">Play Game</button>
<button data-game="single" class="playType">Single-Player</button>
<button data-game="localMultiplayer" class="playType">Local Multi-Player</button>
<button data-game="onlinePlay" class="playType active">Online Multi-Player</button>
<input id='playerName' placeholder="Player Name" value="Sage">
</div>
<p id="playerOneScore" class="score">
0
<p>
<p id="playerTwoScore" class="score">
0
</p>
<div id="grid"> </div>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.1/TimelineMax.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.1/TweenMax.min.js"></script>
<script src="https://cdn.pubnub.com/sdk/javascript/pubnub.4.4.0.min.js"></script>

<script type="text/javascript">

// Global Variables
var grid = [],
	playerOneScore = $('#playerOneScore'),
	playerTwoScore = $('#playerTwoScore'),
	playType = "onlinePlay", //single
	cubeCount = 775,
	gameSpeed = 80, //80
	host = false,
	lookingForGame = false,
	firstRun = true,
	game = true,
	onlinePlayerName,
	potentialHostName,
	potentialChannel,
	opponentName,
	opponentChannel,
	mySnake,
	yourSnake,
	gameClock,
	keyListener,
	food,
	pubnub;

// Listen for game configuration changes
$('.playType').click(function(){
	$('.playType').removeClass("active");
	$(this).addClass("active");
	playType = $(this).data("game");
});

// Game Timeline
var titleScreen = $('#title_screen'),
	title = $('#title'),
	subtitle = $('#subtitle'),
	playButton = $('#playButton'),
	tl = new TimelineMax();
tl.add( TweenLite.to(titleScreen, .5, {opacity:1, display:'flex'}, "intro") );
tl.add( TweenLite.to(title, .25, {opacity:1}, "intro") );
tl.add( TweenLite.to(subtitle, .25, {opacity:1}, "intro") );
tl.add( TweenLite.to(playButton, .25, {opacity:1}, "intro") );
tl.addPause("intro");
tl.add( TweenLite.to(titleScreen, .5, {opacity:0, display:'none'}, "game start") );
tl.addPause("game start");

// Main Function that generates grid
function gridConstructor(){
	for (i = 1; i < cubeCount; i++){
		$('#grid').append("<div id ='" + i + "'></div>");
		grid[i] = new Cube(i);
	}
}

function startGame(){
	game = true;
	switch(playType){
		case "single":
			host = true;
			tl.play();
			mySnake = new Snake("Player 1", "blue", [250, 251, 252], playerOneScore);
			snakeFood();
			playerOneScore.css("left", "50%").css("display", "block");
			keyListener = window.addEventListener('keydown', function(){tracker(event, mySnake)});
			gameClock = window.setInterval(function(){
				mySnake.commitDirection();
				mySnake.move();
			}, gameSpeed);
			break;
		case "localMultiplayer":
			host = true;
			tl.play();
			mySnake = new Snake("Player 1", "blue", [250, 251, 252], playerOneScore);
			yourSnake = new Snake("Player 2", "red", [436, 437, 438], playerTwoScore);
			snakeFood();
			playerOneScore.css("display", "block");
			playerTwoScore.css("display", "block");
			keyListener = window.addEventListener('keydown', function(){tracker(event, mySnake, yourSnake)});
			gameClock = window.setInterval(function(){
				mySnake.commitDirection();
				yourSnake.commitDirection();
				mySnake.move();
				yourSnake.move();
			}, gameSpeed);
			break;
		case "onlinePlay":
			onlinePlayerName = $('#playerName').val()
			matchMaking();
			break;
	}
}

function startOnlineGame(){

	playerOneScore.css("display", "block");
	playerTwoScore.css("display", "block");
	if(host){
		mySnake = new Snake(onlinePlayerName, "blue", [250, 251, 252], playerOneScore);
		yourSnake = new Snake(opponentName, "red", [436, 437, 438], playerTwoScore);
		snakeFood();
		keyListener = window.addEventListener('keydown', function(){tracker(event, mySnake)});
	} else {
		yourSnake = new Snake(opponentName, "red", [250, 251, 252], playerTwoScore);
		mySnake = new Snake(onlinePlayerName, "blue", [436, 437, 438], playerOneScore);
		keyListener = window.addEventListener('keydown', function(){tracker(event, yourSnake)});
	}

	tl.play();

	gameClock = window.setInterval(function(){
		var currentTime = new Date();
		// console.log("Game Tick");
		// console.log(currentTime.getMinutes() + ":" + currentTime.getSeconds() + ":" + currentTime.getMilliseconds());
	    mySnake.move();
		yourSnake.move();
	}, gameSpeed);

	var syncClock = window.setInterval(function(){
		// console.log("Information Tick");
		if(mySnake.actualDirection != mySnake.intendedDirection || yourSnake.actualDirection != yourSnake.intendedDirection){
			console.log("Change detected. Publishing change");
			mySnake.commitDirection();
			yourSnake.commitDirection();
			var publishConfig = {
				channel : opponentChannel,
				message : mySnake.intendedDirection
			};
			pubnub.publish(publishConfig, function(status, response) {
				// console.log(status, response);
			});
		}		
	}, gameSpeed);
}


function resetGame(){
	game = false;
	tl.reverse();
	clearInterval(gameClock);
	grid.map(function(obj){
		obj.occupied = false;
		obj.reverseIt();
	});
	mySnake = undefined;
	yourSnake = undefined;
	playerOneScore.text(0).css("left", "45%").css("display", "none");
	playerTwoScore.text(0).css("display", "none");
}

// Defines Cube Object. Requires index numer
function Cube(cubeNumber){
	this.cubeID = cubeNumber;
	this.color = '#000';
	this.occupied = false;
	this.element = $('#grid #' + cubeNumber);
	
	// Function that animates the cube
	this.animateIt = function (color){
		this.element.css("background-color", color);
		this.color = color;
	}	

	// Reverses animation of a particular animation object.
	this.reverseIt = function (){
		this.element.removeAttr( 'style' );
	}
}

// Tracks button presses and decides what to do with it.
function tracker(event){
	var keyPressed = event.keyCode;
	console.log("KeyPress invoked");
	// console.log("keyCode: " + keyPressed);
	switch(keyPressed){

		// Cool Snake Moves
		case 37:
				// console.log("Detected Left");
				if(mySnake.actualDirection == "Right"){console.log("Snake Bounce blocked");}
				else{
					mySnake.intendedDirection = "Left";
				}
			break;
		case 38:
				// console.log("Detected Up");
				if(mySnake.actualDirection == "Down"){console.log("Snake Bounce blocked");}
				else{
					mySnake.intendedDirection = "Up";
				}
			break;	
		case 39:
				// console.log("Detected Right");
				if(mySnake.actualDirection == "Left"){console.log("Snake Bounce blocked");}
				else{
					mySnake.intendedDirection = "Right";
				}
			break;
		case 40:
				// console.log("Detected Down");
				if(mySnake.actualDirection == "Up"){console.log("Snake Bounce blocked");}
				else{
					mySnake.intendedDirection = "Down";
				}
			break;
	};

	if(playType == "localMultiplayer"){
		switch(keyPressed){
			case 65:
					// console.log("Detected Left");
					if(yourSnake.actualDirection == "Right"){console.log("Snake Bounce blocked");}
					else{
					yourSnake.intendedDirection = "Left";
					}
				break;
			case 87:
					// console.log("Detected Up");
					if(yourSnake.actualDirection == "Down"){console.log("Snake Bounce blocked");}
					else{
					yourSnake.intendedDirection = "Up";
					}
				break;	
			case 68:
					// console.log("Detected Right");
					if(yourSnake.actualDirection == "Left"){console.log("Snake Bounce blocked");}
					else{
					yourSnake.intendedDirection = "Right";
					}
				break;
			case 83:
					// console.log("Detected Down");
					if(yourSnake.actualDirection == "Up"){console.log("Snake Bounce blocked");}
					else{
					yourSnake.intendedDirection = "Down";
					}
				break;		
		}
	}
}

// Produces a random color when called
function randomColor(){
	var color = '#'+Math.floor(Math.random()*16777215).toString(16);
	if (color.length == 7){
		return color;
	} else {
		while (color.length < 7){
			color += "0";
		}
		return color;
	}
}

function snakeFood(position, color){
	if(host){
		food = Math.floor(Math.random() * cubeCount);
		
		// Prevents new food unit from occupying snake
		while (isCollision("", food)){
			console.log("Collision Loop Initiated")
			console.log("Changing Food");
			food = Math.floor(Math.random() * cubeCount);
		}

		var currentColor = randomColor();
		grid[food].animateIt(currentColor);
		if(playType == "onlinePlay"){

			var publishConfig = {
				channel : opponentChannel,
				message : {
					action: "food",
					hostFoodPosition: food,
					hostFoodColor: currentColor
				}
			};
			pubnub.publish(publishConfig, function(status, response) {
				console.log("New Food Published");
			});
		}
	} else {
		food = position;
		console.log("Food is at position: " + food);
		grid[food].animateIt(color);
	}
		grid[food].occupied = true;
}

function Snake(name, color, trailArray, scoreBoard){
	this.name = name,
	this.size = 0,
	this.color = color,
	this.trailArray = trailArray,
	this.position = trailArray[0],
	this.intendedDirection = 'Right',
	this.actualDirection = 'Right',
	this.scoreBoard = scoreBoard,
	this.commitDirection = function(){
		this.actualDirection = this.intendedDirection;
	}
	this.move = function (){
		switch(this.actualDirection){
			case "Left":
				if (this.position % 31 != 0){
					this.position -= 1;
					// console.log("Moving Snake Left");
				} else {
					this.position += 30;
				}
				break;
			case "Right":
				if (this.position % 31 != 0){
					this.position += 1;
					// console.log("Moving Snake Right");
				} else {
					this.position -= 30;
				}
				break;
			case "Up":
				if (this.position > 31){
					this.position += -31;
					// console.log("Moving Snake Up");
				} else {
					this.position += 744;
				}
				break;	
			case "Down":
				if (this.position < (cubeCount - 33)){
					this.position += 31;
					// console.log("Moving Snake Down");
				} else {
					this.position += -744;
				}
				break;	
		}
		// Checks for collision. Ends game if true. Occupies position if false.
		if (!isCollision(this.name, this.position)){
			this.trail();
		} else {
			console.log("Game is over");
			console.log("Snake Object", this);
			clearInterval(gameClock);
			// resetGame();
		}
	}
	this.trail = function (){
		// console.log("Trail at call " + this.trailArray);
		// If food is attained. Skip Array Purge. This allows snake to grow.
		// console.log("food = " + food + " and position = " + this.position);
		this.trailArray.unshift(this.position);
		if (this.position == food){
			// Food gathered. Skipping pop.
			this.size++;
			this.color = grid[food].color;
			this.scoreBoard.text(this.size);
			if(host){snakeFood();}
		} else {
			grid[this.position].animateIt(this.color);
			grid[this.position].occupied = true;
			var popped = this.trailArray.pop();
			if (popped >= 0){
				grid[popped].reverseIt();
				grid[popped].occupied = false;
			}
		}
	}
}

// Detects collision event with food or self
function isCollision(name, position){
	if (position == food){
		// console.log("Food Gathered");
		return false;
	}
	else if (grid[position].occupied == true){
		console.log(name + " has collided");
		console.log("collision at: " + position);
		return true;
	} else {
		return false;
	}
}


function matchMaking(){

	var newUUID = PubNub.generateUUID();
	pubnub = new PubNub({
		uuid: newUUID,
	    publishKey : 'pub-c-fe32255a-2d44-4996-84db-c7a1e52e7dfc',
	    subscribeKey : 'sub-c-2a5abf52-e339-11e6-8d2d-02ee2ddab7fe',
	    presenceTimeout: 10
	});

	pubnub.addListener({
	    status: function(statusEvent){
	        if (statusEvent.category === "PNConnectedCategory") {
	        	if (firstRun){
	        		initializeMatch();
	        	} else {
	        		if (host){
						var publishConfig = {
							channel : opponentChannel,
							message : {
								action: "hello"
							}
						};
						pubnub.publish(publishConfig, function(status, response) {
		        			console.log("Match Confirmed");
						});
					}
	        	}
	        }
	    },
	    message: function(response){
	    	// console.log(response);
	    	switch(response.channel){
	    		case 'match_making':
	    			if(lookingForGame && response.message.potentialHostID == pubnub.getUUID()){
	    				console.log("Opponent Message recieved");
	    				opponentName = response.message.guestName;
	    				opponentChannel = response.message.potentialChannel;
	    				pubnub.unsubscribeAll();
						pubnub.subscribe({
						    channels: [opponentChannel],
						    withPresence: true
						});

	    			} else if(!lookingForGame && response.message.potentialHostID == pubnub.getUUID()){
	    				console.log("I am being addressed, but I am not looking for a game");
	    			} else {
	    				console.log("MatchMaking message does not apply to me");
	    			}

	    			break;

	    		case 'snake_lobby':
	    			// Do something with lobby
	    			break;

	    		default:
	    			// console.log("Message from private channel");
	    			if (response.message.action == "hello"){
		    			if(host){
		    				console.log("I'm the host and the Game is Established");
		    			} else {
							console.log("I'm the guest and the Game is Established");
							opponentChannel = response.channel;
		    			}
						startOnlineGame();

		    		} else if(response.message.action == "food" && response.publisher != pubnub.getUUID()){
		    			console.log("Recieved New Food");
		    			var hostFoodPosition = response.message.hostFoodPosition;
		    			var hostFoodColor = response.message.hostFoodColor;
		    			snakeFood(hostFoodPosition, hostFoodColor);

		    		} else {
		    			if(response.publisher != pubnub.getUUID()){
			    			console.log("Opponent Move recieved");
			    			console.log(response);
			    			yourSnake.intendedDirection = response.message;
			    		}
		    		}
	    			break;
	    	}
	    },
	    presence: function(presenceEvent){
	        // console.log(presenceEvent);
	    }
	});

	// Join Main Lobby and MatchMaking
	pubnub.subscribe({
	    channels: ["snake_lobby", "match_making"],
	    withPresence: true
	});
}

function initializeMatch(){
	firstRun = false;
	var newState = {
	    name: onlinePlayerName,
	};
	pubnub.setState({ 
	    state: newState,
	    channels: ["snake_lobby"]
	},
	function(status, response){

		pubnub.hereNow({
		    channels: ["snake_lobby"],
		    includeState: true,
		    includeUUIDs: true
		},
		function(status, response){
			console.log("Lobby Status:");
		    console.log(response);
		    var snakeLobby = response.channels.snake_lobby;
			// If lobby is empty add self to lobby
			if(snakeLobby.occupancy <= 1 && snakeLobby.occupants[0].uuid == pubnub.getUUID()){
				console.log("No occupants. Switching to host");
				host = true;
				lookingForGame = true;
				
			} else {
				// Potential game found
				var potentialHostID;
				var potentialHostName;
				for(i = 0; i < snakeLobby.occupants.length; i++){
					if (snakeLobby.occupants[i].uuid != pubnub.getUUID()){
						var currentOccupant = snakeLobby.occupants[i];
						potentialHostID = currentOccupant.uuid;
						potentialHostName = currentOccupant.state.name;
						opponentName = currentOccupant.state.name
						console.log("Possible Host Found: " + potentialHostName);
						break;
					}
				}

				console.log("Attempting HandShake");
				host = false;
				var potentialChannel = Math.floor((Math.random() * 100) + 1);
				opponentChannel = potentialChannel;
				var publishConfig = {
					channel : "match_making",
					message : {
						potentialHostID: potentialHostID,
						potentialHostName: potentialHostName,
						potentialChannel: potentialChannel,
						guestName: onlinePlayerName
					}
				};
				pubnub.publish(publishConfig, function(status, response) {
					console.log("Publishing Potential Match");
					pubnub.unsubscribeAll();
					pubnub.subscribe({
					    channels: [potentialChannel],
					    withPresence: true
					});
				});
			}
		});
	});
}

</script>
</body>

</html>