<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Game Alpha</title>
<link href="http://fonts.googleapis.com/css?family=Oswald:400,700" rel="stylesheet" type="text/css">
<style>
* {
	padding: 0;
	border: 0;
	margin: 0;
	box-sizing: border-box;
	font-family: 'Oswald', sans-serif;
}
html {
	height: 100%;
	width: 100%;
}
body {
	height: 100%;
	width: 100%;
	background-color: black;
	overflow: hidden;
}
header {
	height: 10%;
	background-color: white;
}
#title_screen {
	display:flex;
	align-content:center;
	justify-content:center;
	flex-wrap:wrap;
	flex-direction:row;
	background-color: rgba(255,255,255,1);
	opacity:0;
	border-radius: 20px;
	position: absolute;
	top: 50%;
	left: 50%;
	margin: -250px 0 0 -250px;
	z-index: 100;
	width: 500px;
	height: 500px;
}
#title, #subtitle, #playButton {opacity:0;}
#title{font-size:100px;}
#subtitle{font-size:30px;margin-bottom:10px;}
#playButton{background-color:red;font-size:20px;padding:10px;width:100%;height:50px;transition:all 1s;}
#playButton:hover{background-color:blue;}
#grid {
	width: 100%;
	height: 100%;
}
#grid div {
	float: left;
	width: 2vw;
	height: 3vh;
	background-color: black;
	margin: .5vh .5vw .5vh .7vw;
	/*transition: .5s all linear;*/
	border-radius: 100px;
}

</style>
<script src="libraries/jquery/jquery-2.1.4.min.js"></script>
<script src="libraries/greensock/TimelineMax.min.js"></script>
<script src="libraries/greensock/TweenMax.min.js"></script>
</head>

<body onLoad="gridConstructor()">
<!--<header>Snake By Sage</header>-->
<div id="title_screen"> 
<h1 id="title">Snake</h1>
<h2 id="subtitle">Coded By: Sage Pacheco</h2>
<button id="playButton" onClick="startGame()" type="button">Play Game</button>
</div>
<div id="grid"> </div>
</body>
<script type="text/javascript">

// To Do List:
// Change color behavior
//
//
//

// Global Variables
var grid = [],
	cubeCount = 775,
	gameSpeed = 80,
	coolSnake = new Snake("blue", [250, 251, 252]),
	antiSnake = new Snake("red", [499, 500, 501]),
	gameClock,
	keyListener;

// Game Timeline
var titleScreen = $('#title_screen'),
	title = $('#title'),
	subtitle = $('#subtitle'),
	playButton = $('#playButton'),
	tl = new TimelineMax();
tl.add( TweenLite.to(titleScreen, .5, {opacity:1}, "intro") );
tl.add( TweenLite.to(title, .25, {opacity:1}, "intro") );
tl.add( TweenLite.to(subtitle, .25, {opacity:1}, "intro") );
tl.add( TweenLite.to(playButton, .25, {opacity:1}, "intro") );
tl.addPause("intro");
tl.add( TweenLite.to(titleScreen, .5, {opacity:0}, "game start") );
tl.addPause("game start");

// Main Function that generates grid
function gridConstructor(){
	for (i = 1; i < cubeCount; i++){
		$('#grid').append("<div id ='" + i + "'></div>");
		grid[i] = new Cube(i);
	}
}

function startGame(){
	game = true;
	tl.play();
	snakeFood();
	gameClock = window.setInterval(function(){
		coolSnake.moveSnake();
		antiSnake.moveSnake();
	}, gameSpeed);
	keyListener = window.addEventListener('keydown', function(){tracker(event)});
}

function resetGame(){
	game = false;
	tl.reverse();
	clearInterval(gameClock);
	grid.map(function(obj){
		obj.occupied = false;
		obj.reverseIt();
	});
	coolSnake = new Snake("blue", [250, 251, 252]);
	antiSnake = new Snake("red", [499, 500, 501]);

}

// Defines Cube Object. Requires width, height, and index numer
function Cube(cubeNumber){
	this.cubeID = cubeNumber;
	this.color = '#000';
	this.occupied = false;
	this.element = $('#grid #' + cubeNumber);
	
	// Function that animates the cube
	this.animateIt = function (color){
		this.element.css("background-color", color);
		this.color = color;
	}	

	// Reverses animation of a particular animation object.
	this.reverseIt = function (){
		this.element.removeAttr( 'style' );
	}
}

// Tracks button presses and decides what to do with it.
function tracker(event){
	var keyPressed = event.keyCode;
	// console.log("keyCode: " + keyPressed);
	switch(keyPressed){

		// Cool Snake Moves
		case 37:
				// console.log("Detected Left");
				if(coolSnake.direction == "Right"){console.log("Snake Bounce blocked");}
				else{
				coolSnake.direction = "Left";
				}
			break;
		case 38:
				// console.log("Detected Up");
				if(coolSnake.direction == "Down"){console.log("Snake Bounce blocked");}
				else{
				coolSnake.direction = "Up";
				}
			break;	
		case 39:
				// console.log("Detected Right");
				if(coolSnake.direction == "Left"){console.log("Snake Bounce blocked");}
				else{
				coolSnake.direction = "Right";
				}
			break;
		case 40:
				// console.log("Detected Down");
				if(coolSnake.direction == "Up"){console.log("Snake Bounce blocked");}
				else{
				coolSnake.direction = "Down";
				}
			break;

		// Anti Snake Moves
		case 65:
				// console.log("Detected Left");
				if(antiSnake.direction == "Right"){console.log("Snake Bounce blocked");}
				else{
				antiSnake.direction = "Left";
				}
			break;
		case 87:
				// console.log("Detected Up");
				if(antiSnake.direction == "Down"){console.log("Snake Bounce blocked");}
				else{
				antiSnake.direction = "Up";
				}
			break;	
		case 68:
				// console.log("Detected Right");
				if(antiSnake.direction == "Left"){console.log("Snake Bounce blocked");}
				else{
				antiSnake.direction = "Right";
				}
			break;
		case 83:
				// console.log("Detected Down");
				if(antiSnake.direction == "Up"){console.log("Snake Bounce blocked");}
				else{
				antiSnake.direction = "Down";
				}
			break;		
	}
}

// Produces a random color when called
function randomColor(){
	var color = '#'+Math.floor(Math.random()*16777215).toString(16);
	if (color.length == 7){
		return color;
	} else {
		while (color.length < 7){
			color += "0";
		}
		return color;
	}
}

// Snake Algorithms

var game = true;
var food = 0;

function snakeFood(){
	food = Math.floor(Math.random() * (cubeCount - 1));
	
	// Prevents new food unit from occupying snake
	while (isCollision(food)){
		console.log("Collision Loop Initiated")
		console.log("Changing Food");
		food = Math.floor(Math.random() * (cubeCount - 1));
	}
	grid[food].occupied = true;
	grid[food].animateIt(randomColor());
}

function Snake(color, trailArray){
	// console.log("Cool Snake is born");
	this.size = 1;
	this.color = color
	this.trailArray = trailArray;
	this.position = trailArray[1];
	this.direction = 'Right';
	this.moveSnake = function (){
		if(game){
			switch(this.direction){
				case "Left":
					if (this.position % 31 != 0){
						this.position -= 1;
						// console.log("Moving Snake Left");
					} else {
						this.position += 30;
					}
					break;
				case "Right":
					if (this.position % 31 != 0){
						this.position += 1;
						// console.log("Moving Snake Right");
					} else {
						this.position -= 30;
					}
					break;
				case "Up":
					if (this.position > 31){
						this.position += -31;
						// console.log("Moving Snake Up");
					} else {
						this.position += 744;
					}
					break;	
				case "Down":
					if (this.position < (cubeCount - 33)){
						this.position += 31;
						// console.log("Moving Snake Down");
					} else {
						this.position += -744;
					}
					break;	
			}
			// Checks for collision. Ends game if true. Occupies position if false.
			if (!isCollision(this.position)){
				this.trail();
			} else {
				console.log("Game is over");
				resetGame();
			}
		}
	}
	this.trail = function (){
		// console.log("Trail at call " + this.trailArray);
		// If food is attained. Skip Array Purge. This allows snake to grow.
		// console.log("food = " + food + " and position = " + this.position);
		this.trailArray.unshift(this.position);
		if (this.position == food){
			// Food gathered. Skipping pop.
			this.size++;
			this.color = grid[food].color;
			snakeFood();
		} else {
			grid[this.position].animateIt(this.color);
			grid[this.position].occupied = true;
			var popped = this.trailArray.pop();
			if (popped >= 0){
				grid[popped].reverseIt();
				grid[popped].occupied = false;
			}
		}
	}
}

// Detects collision event with food or self
function isCollision(position){
	if (position == food){
		console.log("Food Gathered");
		return false;
	}
	else if (grid[position].occupied == true){
		console.log("Is Collision");
		return true
	} else {
		return false;
	}
}
</script>
</html>
